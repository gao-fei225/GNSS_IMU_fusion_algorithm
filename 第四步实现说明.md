# 第四步实现说明：误差状态 ESKF 模型建立

## 概述

第四步完成了误差状态卡尔曼滤波器（Error-State Kalman Filter, ESKF）的核心数学模型和算法实现，为后续的松耦合和紧耦合融合打下了基础。

## 实现内容

### 1. 误差动力学模型 (`models/error_dynamics.py`)

实现了误差状态的传播方程，包括：

#### 1.1 状态转移矩阵 F
```python
compute_F_matrix(nominal_state, imu_measurement)
```

**F 矩阵结构（15×15）：**
```
┌─────────────────────────────────────────┐
│  -[ω]×   0      0     -C_b^n    0      │  δθ  姿态误差
│ -C_b^n[f]×  0   0       0    -C_b^n    │  δv  速度误差
│    0      I     0       0       0      │  δp  位置误差
│    0      0     0       0       0      │  δbg 陀螺零偏误差
│    0      0     0       0       0      │  δba 加计零偏误差
└─────────────────────────────────────────┘
```

其中：
- `[ω]×`: 角速度的反对称矩阵（skew-symmetric matrix）
- `[f]×`: 比力的反对称矩阵
- `C_b^n`: 机体系到导航系的旋转矩阵
- `I`: 3×3 单位矩阵

**物理含义：**
- **F[0:3, 0:3] = -[ω]×**：姿态误差受角速度影响的耦合项
- **F[0:3, 9:12] = -C_b^n**：陀螺零偏直接导致姿态误差累积
- **F[3:6, 0:3] = -C_b^n·[f]×**：姿态误差与加速度耦合影响速度误差
- **F[3:6, 12:15] = -C_b^n**：加计零偏直接导致速度误差累积
- **F[6:9, 3:6] = I**：速度误差积分产生位置误差
- **零偏误差为随机游走**：dδb/dt = 0，对应 F 矩阵元素为 0

#### 1.2 噪声传递矩阵 G
```python
compute_G_matrix(nominal_state)
```

**G 矩阵结构（15×12）：**
```
┌─────────────────────────┐
│  -C_b^n    0     0     0  │  δθ
│    0    -C_b^n  0     0  │  δv
│    0       0    0     0  │  δp
│    0       0    I     0  │  δbg
│    0       0    0     I  │  δba
└─────────────────────────┘
```

描述过程噪声如何影响误差状态：
- 陀螺白噪声通过旋转矩阵影响姿态误差
- 加计白噪声通过旋转矩阵影响速度误差
- 零偏随机游走直接影响零偏误差

#### 1.3 过程噪声协方差矩阵 Q
```python
compute_Q_matrix(dt)
```

**Q 矩阵（12×12 对角矩阵）：**
```
Q = diag([σ_g²·I(3), σ_a²·I(3), σ_bg²·I(3), σ_ba²·I(3)])
```

噪声参数（功率谱密度 PSD）：
- σ_g：陀螺白噪声 (rad/s/√Hz)
- σ_a：加计白噪声 (m/s²/√Hz)
- σ_bg：陀螺零偏随机游走 (rad/s²/√Hz)
- σ_ba：加计零偏随机游走 (m/s³/√Hz)

#### 1.4 离散化
```python
discretize(F, G, Q, dt)
```

将连续时间误差方程离散化：
- **状态转移矩阵**：Φ ≈ I + F·dt
- **过程噪声协方差**：Qd ≈ G·Q·G^T·dt

对于高采样率的 IMU（如 100Hz），一阶近似已经足够精确。

### 2. ESKF 核心算法 (`fusion/eskf.py`)

实现了 ESKF 的三个核心步骤：

#### 2.1 预测步骤 (Predict)
```python
predict(nominal_state, imu_measurement, dt)
```

**流程：**
1. 计算当前时刻的 F、G、Q 矩阵
2. 离散化得到 Φ 和 Qd
3. 更新协方差矩阵：**P = Φ·P·Φ^T + Qd**

**注意：** 在 ESKF 中，预测步骤**只更新协方差矩阵**，误差状态估计保持为零（因为误差已在上次更新后修正到名义状态中）。

#### 2.2 更新步骤 (Update)
```python
update(innovation, H, R)
```

**标准卡尔曼滤波更新：**
1. 计算新息协方差：S = H·P·H^T + R
2. 计算卡尔曼增益：K = P·H^T·S^(-1)
3. 更新误差状态估计：δx = δx + K·innovation
4. 更新协方差（Joseph 形式）：P = (I - K·H)·P·(I - K·H)^T + K·R·K^T

**Joseph 形式**保证了数值稳定性，即使在数值误差存在时也能保持协方差矩阵的正定性。

#### 2.3 状态修正 (Correction)
```python
correct_nominal_state(nominal_state, gyro_bias, accel_bias)
```

**用误差状态修正名义状态：**

1. **姿态修正**（四元数乘法）：
   - 将小角度误差 δθ 转换为四元数增量：δq ≈ [1, δθ/2]
   - 四元数乘法：q_corrected = q_nominal ⊗ δq
   - 归一化四元数

2. **速度修正**（向量加法）：
   - v_corrected = v_nominal + δv

3. **位置修正**（向量加法）：
   - p_corrected = p_nominal + δp

4. **零偏修正**（向量加法）：
   - b_corrected = b_current + δb

5. **重置误差状态为零**（ESKF 的核心特点）：
   - δx = 0

**为什么要重置误差状态？**
- ESKF 的精髓在于**误差状态始终保持小量**，这样可以使用线性化模型
- 每次更新后，将估计的误差修正到名义状态中，然后重置误差状态为零
- 这避免了误差状态累积导致的线性化误差

## 误差状态方程推导

### 连续时间误差方程

**姿态误差：**
```
dδθ/dt = -[ω]× · δθ - C_b^n · δbg - C_b^n · wg
```

**速度误差：**
```
dδv/dt = -C_b^n · [f]× · δθ - C_b^n · δba - C_b^n · wa
```

**位置误差：**
```
dδp/dt = δv
```

**陀螺零偏误差（随机游走）：**
```
dδbg/dt = wbg
```

**加计零偏误差（随机游走）：**
```
dδba/dt = wba
```

整理成矩阵形式：
```
dδx/dt = F·δx + G·w
```

其中：
- δx = [δθ, δv, δp, δbg, δba]^T （15维）
- w = [wg, wa, wbg, wba]^T （12维过程噪声）

## 辅助函数

### 反对称矩阵（Skew-Symmetric Matrix）
```python
_skew_symmetric(vector)
```

对于向量 v = [v1, v2, v3]^T：
```
[v]× = [[  0,  -v3,   v2],
        [ v3,    0,  -v1],
        [-v2,   v1,    0]]
```

满足：[v]× @ u = v × u（叉乘）

### 四元数转旋转矩阵
```python
_quaternion_to_rotation_matrix(q)
```

将四元数 q = [qw, qx, qy, qz] 转换为 3×3 旋转矩阵 C_b^n。

### 四元数乘法
```python
_quaternion_multiply(q1, q2)
```

四元数乘法公式：q1 ⊗ q2，表示先进行 q2 旋转，再进行 q1 旋转。

### 误差到四元数
```python
_error_to_quaternion(error_rotation)
```

小角度近似：对于 δθ，四元数增量为 δq ≈ [1, δθ/2]。

## 测试验证

运行测试脚本：
```bash
python test/test_eskf.py
```

### 测试内容

1. **误差动力学模型测试**
   - F 矩阵计算验证
   - G 矩阵计算验证
   - Q 矩阵计算验证
   - 离散化验证

2. **ESKF 预测步骤测试**
   - 协方差矩阵增长验证
   - 正定性检查

3. **ESKF 更新步骤测试**
   - 卡尔曼增益计算
   - 误差状态更新
   - 协方差矩阵减小验证

4. **ESKF 状态修正测试**
   - 姿态、速度、位置修正
   - 零偏修正
   - 误差状态重置验证
   - 四元数归一化验证

### 测试结果
```
✓ 所有测试通过！
- 误差动力学模型测试通过
- ESKF预测步骤测试通过
- ESKF更新步骤测试通过
- ESKF状态修正测试通过
```

## 代码结构

### 核心文件
- `models/error_state.py`: 误差状态定义（15维向量）
- `models/error_dynamics.py`: 误差动力学模型（F、G、Q、离散化）
- `fusion/eskf.py`: ESKF核心算法（预测、更新、修正）

### 测试文件
- `test/test_eskf.py`: 完整的单元测试

### 配置文件
- `config/default_config.yaml`: IMU 和 ESKF 参数配置

## ESKF 与传统 KF 的区别

| 特性 | 传统 KF | ESKF |
|------|---------|------|
| **状态定义** | 直接定义姿态、速度、位置 | 定义误差状态（相对于名义状态的偏差） |
| **状态量级** | 状态量可能很大 | 误差状态始终保持小量 |
| **线性化精度** | 大状态量时线性化误差大 | 小误差量时线性化精度高 |
| **姿态表示** | 需要处理四元数约束 | 用 3 维旋转向量表示姿态误差 |
| **状态维数** | 至少 16 维（四元数 4 维） | 只需 15 维（姿态误差 3 维） |
| **协方差维数** | 16×16 或更高 | 15×15 |
| **更新后操作** | 直接使用更新后的状态 | 修正名义状态后重置误差状态 |

## ESKF 的优势

1. **线性化精度高**：误差状态保持小量，线性化假设更合理
2. **计算效率高**：状态维数更低（15 维 vs 16 维）
3. **数值稳定**：避免四元数约束问题
4. **直观理解**：误差状态的物理含义更清晰
5. **易于扩展**：添加新的误差源（如标度因子误差）更方便

## 下一步工作

第四步完成后，已经具备了：
- ✓ 完整的误差状态模型
- ✓ ESKF 预测和更新算法
- ✓ 名义状态修正机制

**接下来可以进行：**
1. **第五步**：实现松耦合 ESKF（INS + GNSS 导航解）
   - 定义量测模型（位置、速度观测）
   - 实现量测更新逻辑
   
2. **第六步**：实现紧耦合 ESKF（INS + GNSS 原始观测）
   - 定义伪距/伪距率量测模型
   - 实现更复杂的量测更新

## 参考资料

1. **Quaternion kinematics for ESKF**: Joan Solà, 2017
2. **ESKF理论基础**：《惯性导航系统》- 严恭敏
3. **GNSS/INS组合导航**：《组合导航原理与应用》- 秦永元

## 联系与支持

如有问题或建议，请参考：
- 项目 README.md
- 代码实现步骤.md
- 各模块的文档注释
