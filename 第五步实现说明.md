# 第五步实现说明：松耦合 ESKF 实现（INS + GNSS 导航解）

## 概述

第五步实现了松耦合ESKF（Loosely Coupled ESKF），使用GNSS导航解（位置和速度）来修正INS的漂移。这是最简单的GNSS/INS融合方案，作为紧耦合的对照基准。

## 实现内容

### 1. 松耦合量测模型 (`models/measurement_models.py`)

#### 1.1 量测设计

**量测向量（6维）：**
```
z = [Δp(3), Δv(3)]^T
```
其中：
- Δp = pos_GNSS - pos_INS（位置残差）
- Δv = vel_GNSS - vel_INS（速度残差）

**量测方程：**
```
z = H · δx + v
```
其中：
- H: 量测矩阵（6×15）
- δx: 误差状态（15维）
- v: 量测噪声（零均值高斯白噪声）

#### 1.2 量测矩阵 H（6×15）

```python
H = [[0_{3×3}, 0_{3×3}, I_{3×3}, 0_{3×3}, 0_{3×3}],  # 位置量测
     [0_{3×3}, I_{3×3}, 0_{3×3}, 0_{3×3}, 0_{3×3}]]  # 速度量测
```

**物理含义：**
- 位置量测直接观测位置误差 δp（误差状态的第6-8维）
- 速度量测直接观测速度误差 δv（误差状态的第3-5维）
- H 是常矩阵，不依赖于状态

**误差状态对应关系：**
```
误差状态：[δθ(0:3), δv(3:6), δp(6:9), δbg(9:12), δba(12:15)]
量测：    [Δp(0:3), Δv(3:6)]

Δp ≈ δp  →  H[0:3, 6:9] = I
Δv ≈ δv  →  H[3:6, 3:6] = I
```

#### 1.3 量测噪声协方差 R（6×6）

```python
R = diag([σ_pos²·I(3), σ_vel²·I(3)])
```

其中：
- σ_pos: GNSS位置噪声标准差（配置文件中典型值：0.1 m）
- σ_vel: GNSS速度噪声标准差（配置文件中典型值：0.01 m/s）

R矩阵是对角矩阵，假设：
- 三个方向的噪声独立同分布
- 位置和速度量测噪声独立

#### 1.4 实现的方法

```python
class LooseCouplingModel(GNSSMeasurementModel):
    def compute_innovation(self, nominal_state, measurement):
        """计算量测新息：GNSS - INS"""
        
    def compute_H_matrix(self, nominal_state=None):
        """计算量测矩阵H（常矩阵）"""
        
    def compute_R_matrix(self):
        """计算量测噪声协方差矩阵R"""
```

### 2. 松耦合 ESKF (`fusion/loose_coupling.py`)

#### 2.1 类继承关系

```python
LooseCouplingESKF(ESKF)
    ↓
继承了ESKF的所有方法：
- predict()：预测步骤
- update()：更新步骤
- correct_nominal_state()：状态修正
```

#### 2.2 核心方法

```python
def process_gnss_measurement(self, nominal_state, gnss_nav, 
                            gyro_bias=None, accel_bias=None):
    """
    处理GNSS导航解量测，执行完整的更新流程
    
    流程：
    1. 计算量测新息（GNSS - INS）
    2. 计算量测矩阵H和量测噪声协方差R
    3. 执行ESKF更新步骤
    4. 用误差状态修正名义状态和零偏
    5. 重置误差状态为零
    
    Returns:
        (修正后的名义状态, 修正后的陀螺零偏, 修正后的加计零偏)
    """
```

### 3. 完整的融合流程

#### 3.1 每个时间步的处理流程

```
┌─────────────────────────────────────────────────┐
│              开始新的时间步                        │
└────────────────┬────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────┐
│  1. INS机械编排（名义状态传播）                     │
│     - 用IMU数据更新姿态、速度、位置                 │
│     - nominal_state = ins.update(gyro, accel, dt)│
└────────────────┬────────────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────────────┐
│  2. ESKF预测步骤                                  │
│     - 计算F、G、Q矩阵                             │
│     - 更新协方差：P = Φ·P·Φ^T + Qd                │
│     - eskf.predict(nominal_state, imu, dt)      │
└────────────────┬────────────────────────────────┘
                 │
                 ▼
         ┌───────┴──────┐
         │  有GNSS数据？  │
         └───────┬──────┘
                 │
         ┌───────┼──────┐
         │ Yes           │ No
         ▼               ▼
┌─────────────────┐   ┌──────────────┐
│ 3. GNSS更新     │   │ 只进行预测    │
│ - 计算新息       │   │ 保持当前状态  │
│ - 计算H、R      │   └──────────────┘
│ - ESKF更新      │
│ - 修正名义状态   │
│ - 重置误差状态   │
└─────────────────┘
         │
         ▼
┌─────────────────────────────────────────────────┐
│              保存当前状态，进入下一时间步            │
└─────────────────────────────────────────────────┘
```

#### 3.2 伪代码

```python
# 初始化
ins = INSMechanization(initial_state)
eskf = LooseCouplingESKF(initial_cov, error_dynamics, measurement_model)
gyro_bias = np.zeros(3)
accel_bias = np.zeros(3)

# 主循环
for t in time_series:
    # 读取IMU数据
    gyro, accel = read_imu(t)
    
    # 1. INS预测（名义状态传播）
    ins.update(gyro, accel, dt)
    nominal_state = ins.get_state()
    
    # 2. ESKF预测（协方差传播）
    imu_measurement = {'gyro': gyro, 'accel': accel}
    eskf.predict(nominal_state, imu_measurement, dt)
    
    # 3. 如果有GNSS数据，执行更新
    if has_gnss_data(t) and not in_outage(t):
        gnss_nav = read_gnss(t)
        
        # GNSS更新和状态修正
        corrected_state, gyro_bias, accel_bias = \
            eskf.process_gnss_measurement(nominal_state, gnss_nav, 
                                         gyro_bias, accel_bias)
        
        # 更新INS状态
        ins.position = corrected_state['position']
        ins.velocity = corrected_state['velocity']
        ins.attitude = corrected_state['attitude']
```

## 测试验证

运行测试：
```bash
python test/test_loose_coupling.py
```

### 测试内容

#### 1. 量测模型测试
- ✅ 新息计算验证
- ✅ H矩阵结构验证
- ✅ R矩阵计算验证

#### 2. ESKF流程测试
- ✅ 预测步骤验证（协方差增长）
- ✅ GNSS更新验证（状态修正）
- ✅ 误差状态重置验证

#### 3. 融合模拟测试
- ✅ 10秒匀速直线运动模拟
- ✅ IMU 100Hz + GNSS 1Hz
- ✅ 融合效果验证

### 测试结果

```
============================================================
✓ 所有测试通过！
============================================================

量测模型测试：
  ✓ 新息计算正确
  ✓ H矩阵结构正确
  ✓ R矩阵计算正确

ESKF流程测试：
  ✓ 预测步骤正常
  ✓ GNSS量测处理正常
  ✓ 误差状态已重置为零

融合模拟测试：
  ✓ INS+GNSS融合模拟测试通过
```

## 松耦合 vs 紧耦合

| 特性 | 松耦合 | 紧耦合 |
|------|--------|--------|
| **GNSS输入** | 导航解（位置、速度） | 原始观测（伪距、伪距率） |
| **量测维数** | 6维（固定） | n×2维（n为卫星数，可变） |
| **量测矩阵** | 常矩阵 | 随卫星几何变化 |
| **计算复杂度** | 低 | 高 |
| **GNSS依赖** | 需要GNSS处理器输出解 | 可以自行处理原始观测 |
| **遮挡鲁棒性** | 较差（需要至少4颗卫星） | 较好（少于4颗也可工作） |
| **精度** | 较低 | 较高 |
| **实现难度** | 简单 | 复杂 |

## 松耦合的优缺点

### 优点

1. **实现简单**
   - H矩阵为常矩阵，不需要复杂的线性化
   - 不需要处理卫星几何和钟差
   - 代码量少，易于调试

2. **计算效率高**
   - 量测维数固定（6维）
   - 矩阵运算规模小
   - 适合实时应用

3. **模块化设计**
   - GNSS模块和INS模块独立
   - 可以使用商用GNSS接收机的导航解
   - 易于集成到现有系统

### 缺点

1. **GNSS依赖性强**
   - 需要GNSS接收机输出有效导航解
   - 通常需要至少4颗卫星
   - 不能充分利用少于4颗卫星的情况

2. **精度受限**
   - 受GNSS导航解精度限制
   - 无法利用原始观测的信息
   - 无法进行更精细的误差建模

3. **遮挡性能差**
   - GNSS遮挡时完全依赖INS
   - 不能部分利用可见卫星
   - 误差累积快

## 使用场景

松耦合ESKF适合以下场景：

1. **GNSS信号良好**
   - 开阔环境
   - 卫星可见数量充足
   - 信号质量好

2. **实时性要求高**
   - 需要低延迟
   - 计算资源有限
   - 功耗敏感

3. **快速原型验证**
   - 算法验证
   - 系统测试
   - 性能评估基准

## 代码结构

### 核心文件
```
models/
  └── measurement_models.py      # 量测模型
      └── LooseCouplingModel     # 松耦合量测模型类

fusion/
  └── loose_coupling.py          # 松耦合ESKF
      └── LooseCouplingESKF      # 松耦合ESKF类

test/
  └── test_loose_coupling.py     # 完整测试
```

### 配置参数
```yaml
gnss_params:
  position_noise: 0.1    # 位置噪声 (m)
  velocity_noise: 0.01   # 速度噪声 (m/s)
```

## 扩展建议

基于松耦合ESKF，可以进行以下扩展：

1. **自适应滤波**
   - 根据GNSS信号质量动态调整R矩阵
   - 根据创新新息检测异常量测
   - 实现故障检测与排除（FDE）

2. **多传感器融合**
   - 加入轮速计约束
   - 加入磁力计观测
   - 加入气压高度计

3. **约束优化**
   - 零速检测与更新（ZUPT）
   - 非完整性约束（车辆运动模型）
   - 地图匹配约束

4. **性能评估**
   - 实时监控协方差矩阵
   - 计算可用性指标
   - 生成完整性告警

## 下一步工作

第五步完成后，已经具备：
- ✅ 完整的松耦合ESKF实现
- ✅ 量测模型和融合算法
- ✅ 完整的测试验证

**接下来可以进行：**
1. **第六步**：紧耦合ESKF（INS + GNSS原始观测）
   - 实现伪距/伪距率量测模型
   - 处理卫星几何和钟差
   - 实现更复杂的H矩阵计算

2. **性能对比实验**
   - 对比纯INS、松耦合、紧耦合
   - 分析不同场景下的性能
   - 生成性能评估报告

## 参考资料

1. **GNSS/INS组合导航**：《组合导航原理与应用》- 秦永元
2. **松耦合vs紧耦合**：Groves, P.D. "Principles of GNSS, Inertial, and Multisensor Integrated Navigation Systems"
3. **ESKF理论**：Joan Solà, "Quaternion kinematics for ESKF", 2017
